<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ejecutar Rutina</title>
  <link rel="shortcut icon" href="favicon.png">
  <!-- CSS -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet"/>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/5.0.0/normalize.min.css">
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;700&display=swap" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    * { font-family: 'Montserrat', sans-serif; }
  </style>
</head>
<body class="bg-gray-100">
  <!-- Header: Nombre de la rutina y timeline centrados, ancho completo -->
  <header class="w-full p-4 flex flex-col items-center">
    <h1 id="routineName" class="text-3xl font-bold text-green-600 text-center mb-2"></h1>
    <div id="progressTimeline" class="w-full flex space-x-1"></div>
  </header>
  
  <!-- Contenedor principal -->
  <div id="mainDisplay" class="flex flex-col items-center justify-center p-4">
    <div id="exerciseDetails" class="flex flex-col items-center justify-center">
      <!-- Título o nombre del ejercicio, preparación, descanso o finalización -->
      <div id="exerciseName" class="text-3xl font-bold mb-2"></div>
      <!-- Contador o métrico -->
      <div id="exerciseMetric" class="text-2xl text-green-600 mb-2"></div>
      <!-- Imagen: Se usa para mostrar la imagen del ejercicio en estado normal, o la del siguiente ejercicio en preparación/descanso -->
      <div id="exerciseImageContainer" class="mb-4">
        <img id="exerciseImage" src="" alt="Imagen del ejercicio" class="w-full max-w-md object-contain">
      </div>
      <!-- Información del siguiente ejercicio (solo se muestra en preparación y descanso) -->
      <div id="nextExerciseInfo" class="text-xl font-medium mb-2"></div>
      <!-- Botón "Listo" (solo para ejercicios de repeticiones) -->
      <button id="actionButton" class="bg-green-600 text-white px-4 py-2 rounded-md hover:bg-green-700 hidden">
        Listo
      </button>
    </div>
  </div>

  <script>
    // Función para obtener parámetros de la URL (ej: ?id=1741621155995)
    function getQueryParam(param) {
      const urlParams = new URLSearchParams(window.location.search);
      return urlParams.get(param);
    }

    // Carga la rutina desde "todas_las_rutinas.json"
    async function loadRoutineFromJSON() {
      try {
        const response = await fetch('todas_las_rutinas.json');
        if (!response.ok) throw new Error("Error al cargar el JSON");
        const routines = await response.json();
        const routineId = Number(getQueryParam('id'));
        console.log("Rutina ID obtenido:", routineId);
        const routine = routines.find(r => r.id === routineId);
        if (!routine) {
          document.body.innerHTML = '<div class="text-center mt-10 text-xl text-red-600">Rutina no encontrada</div>';
          throw new Error("Rutina no encontrada");
        }
        return routine;
      } catch (error) {
        console.error("Error cargando la rutina:", error);
      }
    }

    // Variables globales
    let routine;
    let currentExerciseIndex = -1;
    let exerciseTimer = null;
    let restTimer = null;
    let currentCountdown = 0;
    let imageInterval = null;

    const STATE_PREPARATION = 'preparation';
    const STATE_EXERCISE = 'exercise';
    const STATE_REST = 'rest';
    const STATE_COMPLETED = 'completed';
    let currentState = '';

    // Referencias a elementos del DOM
    const routineNameElem = document.getElementById('routineName');
    const progressTimelineElem = document.getElementById('progressTimeline');
    const exerciseNameElem = document.getElementById('exerciseName');
    const exerciseMetricElem = document.getElementById('exerciseMetric');
    const actionButton = document.getElementById('actionButton');
    const nextExerciseInfoElem = document.getElementById('nextExerciseInfo');
    const exerciseImageContainer = document.getElementById('exerciseImageContainer');
    const exerciseImageElem = document.getElementById('exerciseImage');

    // Actualiza el timeline: Cada segmento representa un ejercicio
    function updateProgressTimeline() {
      progressTimelineElem.innerHTML = '';
      const total = routine.exercises.length;
      for (let i = 0; i < total; i++) {
        const segmentContainer = document.createElement('div');
        segmentContainer.className = 'flex-1 bg-gray-300 h-2 rounded overflow-hidden mx-1';
        const progressBar = document.createElement('div');
        progressBar.className = 'h-full bg-green-600';
        let width = '0%';
        if (i < currentExerciseIndex) {
          width = '100%';
        } else if (i === currentExerciseIndex && currentState === STATE_EXERCISE && routine.exercises[i].type === 'time') {
          const totalTime = parseInt(routine.exercises[i].time);
          const elapsed = totalTime - currentCountdown;
          width = Math.min((elapsed / totalTime) * 100, 100) + '%';
        }
        progressBar.style.width = width;
        segmentContainer.appendChild(progressBar);
        progressTimelineElem.appendChild(segmentContainer);
      }
    }

    // Pantalla de Preparación (antes del primer ejercicio)
    function startPreparation() {
      currentState = STATE_PREPARATION;
      exerciseNameElem.textContent = "Preparación";
      currentCountdown = 10; // 10 segundos de preparación
      exerciseMetricElem.textContent = currentCountdown < 10 ? "0" + currentCountdown : currentCountdown;
      actionButton.classList.add('hidden');

      // Mostrar información del siguiente ejercicio (el primero)
      if(routine.exercises.length > 0) {
        let nextExercise = routine.exercises[0];
        nextExerciseInfoElem.textContent = "Siguiente ejercicio: " + nextExercise.title;
        if(nextExercise.images && nextExercise.images.length > 0) {
          exerciseImageElem.src = nextExercise.images[0];
          exerciseImageContainer.style.display = 'block';
        } else {
          exerciseImageContainer.style.display = 'none';
        }
      } else {
        nextExerciseInfoElem.textContent = "";
      }

      updateProgressTimeline();
      const prepInterval = setInterval(() => {
        currentCountdown--;
        exerciseMetricElem.textContent = currentCountdown < 10 ? "0" + currentCountdown : currentCountdown;
        if (currentCountdown <= 0) {
          clearInterval(prepInterval);
          startNextExercise();
        }
      }, 1000);
    }

    // Inicia el siguiente ejercicio
    function startNextExercise() {
      // Limpia timers e intervalos previos
      if (exerciseTimer) { clearInterval(exerciseTimer); exerciseTimer = null; }
      if (restTimer) { clearInterval(restTimer); restTimer = null; }
      if (imageInterval) { clearInterval(imageInterval); imageInterval = null; }

      currentExerciseIndex++;
      if (currentExerciseIndex >= routine.exercises.length) {
        finishRoutine();
        return;
      }
      // En estado de ejercicio se oculta la info del siguiente ejercicio
      nextExerciseInfoElem.textContent = "";
      updateProgressTimeline();
      const exercise = routine.exercises[currentExerciseIndex];
      currentState = STATE_EXERCISE;
      
      // Muestra el nombre y métrico del ejercicio
      exerciseNameElem.textContent = exercise.title;
      if (exercise.type === 'reps') {
        exerciseMetricElem.textContent = 'x' + exercise.reps;
        actionButton.textContent = 'Listo';
        actionButton.classList.remove('hidden');
      } else {
        let totalSeconds = parseInt(exercise.time) || 0;
        let secondsStr = totalSeconds < 10 ? '0' + totalSeconds : totalSeconds;
        exerciseMetricElem.textContent = '00:' + secondsStr;
        actionButton.classList.add('hidden');
      }

      // Muestra la imagen del ejercicio y configura la alternancia si hay dos imágenes
      if (exercise.images && exercise.images.length > 0) {
        exerciseImageElem.src = exercise.images[0];
        exerciseImageContainer.style.display = 'block';
        let imageIndex = 0;
        if (exercise.images.length === 2) {
          imageInterval = setInterval(() => {
            imageIndex = (imageIndex + 1) % 2;
            exerciseImageElem.src = exercise.images[imageIndex];
          }, 1000);
        }
      } else {
        exerciseImageContainer.style.display = 'none';
      }

      // Si es ejercicio de tiempo, iniciar cuenta regresiva
      if (exercise.type === 'time') {
        currentCountdown = parseInt(exercise.time) || 0;
        exerciseTimer = setInterval(() => {
          currentCountdown--;
          let sec = currentCountdown < 10 ? '0' + currentCountdown : currentCountdown;
          exerciseMetricElem.textContent = '00:' + sec;
          updateProgressTimeline();
          if (currentCountdown <= 0) {
            clearInterval(exerciseTimer);
            // Reproducir sonido al terminar el ejercicio de tiempo
            new Audio('multimedia/listo.mp3').play();
            finishExerciseNormally();
          }
        }, 1000);
      }
    }

    // Finaliza el ejercicio de forma normal (tiempo terminado o pulsar "Listo")
    function finishExerciseNormally() {
      if (exerciseTimer) { clearInterval(exerciseTimer); exerciseTimer = null; }
      if (imageInterval) { clearInterval(imageInterval); imageInterval = null; }
      startRest();
    }

    // Pantalla de Descanso: se muestra "Descanso", el timer y la información del siguiente ejercicio
    function startRest() {
      currentState = STATE_REST;
      exerciseNameElem.textContent = "Descanso";
      currentCountdown = 10; // 10 segundos de descanso
      exerciseMetricElem.textContent = currentCountdown < 10 ? "0" + currentCountdown : currentCountdown;
      actionButton.classList.add('hidden');

      // Mostrar información del siguiente ejercicio (si existe)
      if (routine.exercises[currentExerciseIndex + 1]) {
        let nextExercise = routine.exercises[currentExerciseIndex + 1];
        nextExerciseInfoElem.textContent = "Siguiente ejercicio: " + nextExercise.title;
        if(nextExercise.images && nextExercise.images.length > 0) {
          exerciseImageElem.src = nextExercise.images[0];
          exerciseImageContainer.style.display = 'block';
        } else {
          exerciseImageContainer.style.display = 'none';
        }
      } else {
        nextExerciseInfoElem.textContent = "";
      }

      updateProgressTimeline();
      restTimer = setInterval(() => {
        currentCountdown--;
        exerciseMetricElem.textContent = currentCountdown < 10 ? "0" + currentCountdown : currentCountdown;
        if (currentCountdown <= 0) {
          clearInterval(restTimer);
          startNextExercise();
        }
      }, 1000);
    }

    // Pantalla final: Marca la rutina como completada y redirige a index.html
    function finishRoutine() {
      currentState = STATE_COMPLETED;
      exerciseNameElem.textContent = '¡Felicidades!';
      exerciseMetricElem.textContent = 'Rutina Completada';
      nextExerciseInfoElem.textContent = "";
      actionButton.classList.add('hidden');
      updateProgressTimeline();

      // Marcar la rutina como completada en localStorage
      let completed = JSON.parse(localStorage.getItem('completedRoutines')) || [];
      if (!completed.includes(routine.id)) {
        completed.push(routine.id);
        localStorage.setItem('completedRoutines', JSON.stringify(completed));
      }
      
      new Audio('multimedia/final.mp3').play();
      // Redirigir a index.html después de 3 segundos
      setTimeout(() => {
        window.location.href = "index.html";
      }, 3000);
    }

    // Eventos para el botón "Listo" y navegación con teclas
    actionButton.addEventListener('click', () => {
      if (currentState === STATE_EXERCISE) {
        finishExerciseNormally();
      }
    });

    document.addEventListener('keydown', (e) => {
      // Con Enter se activa el botón "Listo" (si está visible)
      if (e.key === 'Enter' && currentState === STATE_EXERCISE && !actionButton.classList.contains('hidden')) {
        actionButton.click();
      }
      // Con flecha derecha se avanza inmediatamente (omitiendo preparación/descanso)
      if (e.key === 'ArrowRight' && (currentState === STATE_EXERCISE || currentState === STATE_REST || currentState === STATE_PREPARATION)) {
        if (exerciseTimer) { clearInterval(exerciseTimer); exerciseTimer = null; }
        if (restTimer) { clearInterval(restTimer); restTimer = null; }
        if (imageInterval) { clearInterval(imageInterval); imageInterval = null; }
        startNextExercise();
      }
      // Con flecha izquierda se retrocede (si existe ejercicio anterior) sin esperar descanso
      if (e.key === 'ArrowLeft' && currentExerciseIndex > 0) {
        if (exerciseTimer) { clearInterval(exerciseTimer); exerciseTimer = null; }
        if (restTimer) { clearInterval(restTimer); restTimer = null; }
        if (imageInterval) { clearInterval(imageInterval); imageInterval = null; }
        currentExerciseIndex -= 2;
        startNextExercise();
      }
    });

    async function init() {
      routine = await loadRoutineFromJSON();
      routineNameElem.textContent = routine.name;
      // Inicia con la pantalla de Preparación antes del primer ejercicio
      startPreparation();
    }
    init();
  </script>
</body>
</html>